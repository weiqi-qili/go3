<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>简易围棋挂盘演示 (SGF编辑)</title>
    <!-- 引入 WGo.js 核心库 -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/wgo@1.0.3/wgo.min.js"></script>
    <style>
        body {
            font-family: "Microsoft YaHei", sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 1200px;
            width: 100%;
            justify-content: center;
        }

        /* 棋盘区域 */
        #board-container {
            width: 600px;
            height: 600px; /* 默认大小，JS会自适应 */
        }

        /* 控制区域 */
        .controls {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            background-color: #e0e0e0;
            color: #333;
        }

        button:hover {
            background-color: #d0d0d0;
        }

        button.primary {
            background-color: #4a90e2;
            color: white;
        }

        button.primary:hover {
            background-color: #357abd;
        }

        button.danger {
            background-color: #e74c3c;
            color: white;
        }

        label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
            user-select: none;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }

        .status-bar {
            padding: 10px;
            background: #eef;
            border-radius: 4px;
            font-size: 14px;
            color: #444;
        }

        /* 响应式调整 */
        @media (max-width: 900px) {
            #board-container {
                width: 100%;
                max-width: 500px; /* 移动端限制最大宽度 */
                aspect-ratio: 1 / 1;
                height: auto;
            }
        }
    </style>
</head>
<body>

    <h1>在线围棋挂盘 (SGF编辑器)</h1>

    <div class="main-container">
        <!-- 棋盘容器 -->
        <div id="board-container"></div>

        <!-- 右侧控制栏 -->
        <div class="controls">
            <div class="status-bar" id="game-info">
                当前手数: 0 | 轮到: 黑方
            </div>

            <div class="btn-group">
                <button onclick="prevNode()">上一步</button>
                <button onclick="nextNode()">下一步</button>
                <button onclick="resetGame()" class="danger">重置/清空</button>
                <label>
                    <input type="checkbox" id="show-coord" checked onchange="toggleCoord()"> 显示坐标
                </label>
                <label>
                    <input type="checkbox" id="show-marker" checked onchange="refreshBoard()"> 显示手数
                </label>
            </div>

            <div>
                <p style="margin: 5px 0; font-weight: bold; font-size: 14px;">SGF 数据 (可复制或粘贴):</p>
                <textarea id="sgf-area" placeholder="在此处粘贴 SGF 内容..."></textarea>
            </div>

            <button class="primary" onclick="loadFromSGF()">从文本框加载 SGF</button>
        </div>
    </div>

    <script>
        var game;
        var board;
        var boardWidth;

        // 初始化
        window.onload = function() {
            initGame();
        };

        function initGame() {
            // 1. 初始化游戏逻辑对象
            game = new WGo.Game();

            // 2. 初始化棋盘 UI
            // 如果已经存在棋盘，先清空DOM
            var container = document.getElementById("board-container");
            container.innerHTML = "";
            
            // 获取容器实际宽度来设置棋盘大小
            boardWidth = container.clientWidth;
            
            board = new WGo.Board(container, {
                width: boardWidth,
                size: 19,
                section: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            });

            // 3. 绑定点击事件
            board.addEventListener("click", function(x, y) {
                // 尝试下子
                var result = game.play(x, y);
                
                // result 可能是数字代码或对象。 0 或 {code: 0} 代表成功
                // WGo.Game.play 返回值：0:成功, 1:非法(有子), 2:自杀, 3:打劫, 4:非轮次(通常不会触发)
                
                var code = (typeof result === 'object') ? result.code : result;

                if (code === 0) {
                    refreshBoard();
                    updateSGFText();
                    updateStatus();
                } else {
                    // 可以根据 code 提示错误，这里简单忽略无效点击
                    console.log("无效落子 Code: " + code);
                }
            });

            // 初始化界面状态
            updateSGFText();
            updateStatus();
        }

        // 刷新棋盘显示
        function refreshBoard() {
            // 获取当前局面的对象
            var state = game.getPosition();
            
            // 准备绘制对象
            var updateObj = {
                objects: []
            };

            // 遍历棋盘
            for(var x = 0; x < 19; x++) {
                for(var y = 0; y < 19; y++) {
                    var color = state.get(x, y); // 1: 黑, -1: 白, 0: 空
                    if(color !== 0) {
                        var obj = {
                            x: x,
                            y: y,
                            c: (color === 1) ? WGo.B : WGo.W
                        };
                        
                        // 如果勾选了显示手数
                        if(document.getElementById('show-marker').checked) {
                            // 查找这颗子是第几手下的
                            // 这是一个简化的查找，实际只需重绘最近的一手会有标记，
                            // 但为了演示简单，我们只标记最后一手，或者您可以扩展遍历 stack
                        }
                        
                        updateObj.objects.push(obj);
                    }
                }
            }
            
            // 重新绘制棋盘状态
            // WGo board.update() 接受一个对象列表
            // 为了更彻底的刷新，我们先清空棋子层，再画
            // 但 WGo.Board 有 getState 和 updateState 更好用
            
            // 简单方法：利用 Game 对象自带的 board state
            // 下面这行代码把 Game 的逻辑棋盘映射到 UI 棋盘
            var stateObjects = [];
            
            // 绘制棋子
            for(var i=0; i<19; i++){
                for(var j=0; j<19; j++){
                    var c = game.getPosition().get(i,j);
                    if(c != 0) {
                        var stone = { x:i, y:j, c: (c==1)? WGo.B : WGo.W };
                        
                        // 显示手数逻辑 (查找当前坐标在历史中的最后一步)
                        if(document.getElementById('show-marker').checked) {
                            var moveNum = getMoveNumber(i, j);
                            if(moveNum > 0) {
                                stone.text = { 
                                    text: moveNum.toString(), 
                                    color: (c==1)? "white" : "black", // 黑子白字，白子黑字
                                    font: "12px Arial"
                                };
                            }
                        }
                        stateObjects.push(stone);
                    }
                }
            }
            
            // 标记最后一手（红色标记）
            if (game.turn > 0) {
                var lastMove = game.stack[game.turn].move;
                if(lastMove) {
                    // 如果已经有文字（手数），则不加标记，或者加个圈在外面？
                    // 简单起见，这里只确保数据正确，WGo会自动处理重绘
                    // 这里我们为了强调最后一手，给它加个特殊样式（可选）
                }
            }

            board.removeAllObjects();
            board.addObject(stateObjects);
        }

        // 辅助函数：获取某坐标是第几手
        function getMoveNumber(x, y) {
            // 倒序查找 stack
            for(var i = game.stack.length - 1; i > 0; i--) {
                var move = game.stack[i].move;
                // move 结构: {x, y, c}，如果是 pass 则无 x,y
                if(move && move.x === x && move.y === y) {
                    // 还需要确认这颗子之后没有被提掉
                    // 只要当前棋盘这个位置有子，且最后一次在这个位置落子是 i，就是第 i 手
                    // 由于提子比较复杂，这里简化处理：只看 History 中该位置最后一次落子
                    // 并且当前位置确实有子
                    return i;
                }
            }
            return 0;
        }

        // 下一步
        function nextNode() {
            if (game.isOnTarget()) return; // 已经在最后
            game.next();
            refreshBoard();
            updateStatus();
        }

        // 上一步
        function prevNode() {
            if (game.turn === 0) return; // 已经在开始
            game.previous();
            refreshBoard();
            updateStatus();
        }

        // 重置
        function resetGame() {
            if(confirm("确定要清空棋盘吗？")) {
                game = new WGo.Game();
                refreshBoard();
                updateSGFText();
                updateStatus();
            }
        }

        // 从文本框加载 SGF
        function loadFromSGF() {
            var sgfContent = document.getElementById("sgf-area").value;
            if (!sgfContent.trim()) {
                alert("请输入 SGF 内容");
                return;
            }

            try {
                // 加载 SGF
                game.loadSgf(sgfContent);
                // 移动到最后一步
                // game.last(); // 如果想加载后直接看结果取消注释
                // 或者是回到第一步？通常挂盘演示可能希望停在开头
                game.first(); 
                
                refreshBoard();
                updateStatus();
            } catch (e) {
                alert("SGF 格式解析错误，请检查内容。");
                console.error(e);
            }
        }

        // 更新文本框中的 SGF
        function updateSGFText() {
            var sgf = game.toSgf();
            document.getElementById("sgf-area").value = sgf;
        }

        // 更新状态文字
        function updateStatus() {
            var turnColor = (game.turn % 2 === 0) ? "黑方" : "白方";
            // 检查游戏是否结束的标记通常不在 core 里，这里只显示轮次
            document.getElementById("game-info").innerText = 
                "当前手数: " + game.turn + " | 下一手: " + turnColor;
        }
        
        // 切换坐标显示
        function toggleCoord() {
            var show = document.getElementById("show-coord").checked;
            board.setSection({
                top: show ? 1 : 0,
                right: show ? 1 : 0,
                bottom: show ? 1 : 0,
                left: show ? 1 : 0
            });
            // 调整大小时会重绘，所以不需要手动 refresh
        }

        // 窗口大小改变时重绘棋盘以自适应
        window.addEventListener('resize', function() {
            var container = document.getElementById("board-container");
            var newWidth = container.clientWidth;
            if(Math.abs(newWidth - boardWidth) > 20) { // 只有变化较大时才重绘
                boardWidth = newWidth;
                board.setWidth(newWidth);
            }
        });

    </script>
</body>
</html>
